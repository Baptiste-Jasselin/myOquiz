# S05E05 - Sequelize

## Menu du jour 

```
- Correction challenge
  - Tous les modÃ¨les Sequelize

- Associations Sequelize
  - Mise en place
  - Quelques tests

- Oquiz is alive !
  - Ã‰noncÃ© **atelier PP**
  - Pas de challenge ğŸ‰

- RÃ©visions (facultatifs)
  - Pages d'administration des levels
  - Ocode (prÃ©paration du parkour solo) :
    - Lutins (Sequelize, mise en place des models et associations)
    - RequÃªtes complexes (jointures)
```


## Import export 

```js
// associations.js

module.exports = { Quiz, Question };
```

```js
// main.js

const { Quiz, Question } = require("./associations");
```

----

```js
// Vehicule.js

module.exports = Vehicule;
```

```js
// main.js

const Vehicule = require("./Vehicule");
```

## Alias d'une association

```js
Question.belongsTo(Level, {
  foreignKey: "level_id", // OBLIGATOIRE : prÃ©ciser le nom de la clÃ© Ã©trangÃ¨re
  as: "level" // FACULTATIF : PrÃ©ciser l'alias de l'association, pour faciliter la query
});

Level.hasMany(Question, {
  foreignKey: "level_id",
  as: "questions"
});
```

L'alias permet de faire l'appel de cette maniÃ¨re : 

```js
// Sans alias 
const { Question, Level } = require("...")
Question.findOne({ include: Level }); // => ici, on est obligÃ© d'importer Level

// Avec alias 
const { Question } = require("...")
Question.findOne({ include: "level" }); // => ici, pas besoin d'importer Level, on se sert de l'alias
```

Ca change aussi le nom de l'atribut renvoyÃ© : 

```js

// Sans alias 
const question = await Question.findOne({ include: Level }); 
// question = { id, description, wiki, anecdote, Level: { ... } }

// Avec l'alias
const question = await Question.findOne({ include: "level" }); 
// question = { id, description, wiki, anecdote, level: { ... } }
```


```js
// Sans alias 
const level = await Level.findOne({ include: Quiz }); 
// question = { id, name, Quiz: [{}, {}, {}] }
//                        ^ problÃ¨me, le nom du champs n'indique pas que c'est un array !

// Avec l'alias
const level = await Level.findOne({ include: "quizzes" }); 
// question = { id, name, quizzes: [{}, {}, {}] }
//                        ^ on est content, c'est bien nommÃ© !
```

## `toJSON()` vs `get()` vs `JSON.stringify()`

Rappel : c'est uniquement pour TESTER, pour amÃ©liorer l'affichage du `console.log` et s'y retrouver plus facilement

Si on a un OBJET, on peux utiliser : 
- `.get(question)`
- `.toJSON(question)` : 
  - ici, on stringify aussi les champs "included"
  - Ã  privilÃ©gier donc !

Si on a un TABLEAU d'OBJETS, on peut utiliser : 
- `JSON.stringify(questions)`


Par exemple : 

```js
const users = await User.findAll(); // [{}, {}]
console.log(users); // [{ ... bcp de chose du Model Sequelize ... }]
console.log(JSON.stringify(users)); // [{....}, {....}, {....}]
console.log(JSON.stringify(users, null, 2)); // pour sauter des lignes entre les attributs
```

```js
const user = await User.findByPk(1); // {}
console.log(user); // { ... bcp de chose du Model Sequelize ... }
console.log(user.get()); // { id, firstname, lastname, email, password }
console.log(user.toJSON()); // { id, firstname, lastname, email, password }
```

## `Pull Request`

Quand on dÃ©veloppe sur une branche, avant de merger son code sur la branche principale, on aime bien : 
- se relire
- faire relire son code Ã  d'autres devs du projet 
  - pour progresser
  - pour homogÃ©nÃ©iser le code
  - pour attraper quelques bugs avant qu'ils arrivent sur la branche principale 

Pour cela, on `push` la branche sur Github et on crÃ©er une Pull Request : 
- `PR` = `Pull Request` = demande d'intÃ©gration du code d'une branche dans une autre

DÃ©marche : 
- Push la branche
- CrÃ©er la PR sur Github
- Faire valider la PR (optionel si on est seul)
- Button "Merge"
  - le code de `main` sur Github est Ã  jour !
- Puis en local, mettre Ã  jour notre `main` (local) avec le `main` du remote (Github)
  - `git pull`


## A faire

- Quelques exercices / questions bonus
- Recap' saison
- EnoncÃ© de l'atelier PP
- DEUX OPTIONS (aprÃ¨s 14h) : 
  - autonomie sur l'exo des pages des Levels
  - correction guidÃ©e des pages des Levels (avec replay !)

## Bilan de saison 

- Gestion de projet : 
  - Clarification du besoin
  - Kanban
  - Wireframe
  - User-stories

- Architecture : 
  - Variables d'environnement
  - Router
  - Controlleurs
  - `.gitignore`
  - `ESLint`
  - `public`
  - MVC : 
    - ModÃ¨le (Sequelize)
    - View (EJS)
    - Controller (Express)

- ModÃ©lisation : 
  - MCD (conceptuel -> pour Mamie) : qu'est-ce qu'on stock
  - MLD (logique -> pour les techos) : comment on le stock
  - MPD (physique -> pour le SGBD) : stockons le (avec les types)

- POO : 
  - Fabrique (`class`)
  - Instance (`new`) (un "representant" de la classe)
  - Constructor (`constructor`) pour crÃ©er des instances
  - PropriÃ©tÃ©s / Attributs 
    - privÃ©es (`#`)
    - publiques
  - Getters :
    - concept (`getFullName()`)
    - sucre JS (`get firstname()`)
  - Setters : 
    - concept (`set("name", "Harry")` / `setName("Harry")`)
    - sucre JS (`set firstname(value)`)
  - HÃ©ritage : 
    - `extends`
    - principe : crÃ©er une "sous-classe" qui hÃ©rite des propriÃ©tÃ©s ET des mÃ©thodes de la classe parente
    - `super()` appeler le constructor de la classe parente

- Active Record : 
  - `class Tag {}` 
  - reprÃ©sente la structure de nos tables
  - les instances de la classe reprÃ©sente les **enregistrements** dans la table
  - la classe embarque des mÃ©thodes pour accÃ©der directement Ã  la BDD
  - dans notre cas, remplacer le `dataMapper`

- Sequelize (ORM) : 
  - Installation
  - CrÃ©ation du client `sequelize-client` pour se connecter Ã  notre BDD
  - Mise en place des modÃ¨les (`extends Model`)
  - Mise en place des associations
  - On a testÃ© => mais en pratique, on attaque les controlleurs !

- Git / Github : 
  - crÃ©er une branche
  - merger une branche dans une autre
  - commit rÃ©guliÃ¨rement
  - crÃ©er une PR pour Ãªtre relu
  - changer de branche
